1. 
new operator(即 new 操作符)总是做这两件事，无论如何你是不能改变其行为。
new操作符是由C++语言内建的, 就像sizeof那样, 不能改变意义, 总是做相同的事情:
    调用operator new (sizeof(A))
    调用A:A()
    返回指针

第一: 它分配足够的内存, 用来放置某类型的对象.
void * operator new (size_t size);
其返回类型void*. 即返回一个指针, 指向一块原始的, 未设置初始值的内存。
函数中的size_t参数表示需要分配多少内存, 你可以将operator new 重载, 加上额外的参数, 但第一个参数类型必须总是size_t.

第二: 它调用一个构造函数, 为刚才分配的内存中的那个对象设定初始值。

第三: 对象被分配了空间并构造完成, 返回一个指向该对象的指针


同样, delete关键字做两件事:
第一: 调用对象析构函数
第二: 调用operator delete( )释放对象所占用的内存

string* pte = new string("KobeBryant");
delete ptr -> ptr->~string -> operator delete( ptr )
void operator delete(void* memoryToBeDeallocated);
同样, 我们能做的也只有重载operator delete( void* ) 来自己手动管理内存释放


2. 
类中静态数据成员与静态类方法: 
静态数据成员: 属于所有对象而不是特定对象, 为了实现共享数据
静态类方法: 通过类名::FunName( )调用, 不能通过对象调用.
它们不能通过对象调用是因为它们没有隐含的this指针

class LeakDetector{
public:
	// LeakDetector.cpp和被测试的.cpp都会包 LeakDetector.h头文件
	// 因此两个源文件中会创建两个静态LeakDetector类对象 exitCounter (两个静态类对象同名, 但是它们的链接属性均为内链接(只在当前源文件有效), 因此不会重定义), 
    // 如果此时两个对象析构, 会调用两次析构函数, 调用两次内存泄漏检测函数. 而我们的预期是只调用一次内存泄漏检测函数. 所以我们声明一个所有类对象共享的静态变量来实现我们的目的
	static size_t _callCount;
 
	LeakDetector( ){ ++_callCount; }
	~LeakDetector( ){ if(0 == --_callCount) _LeakDetector( ); }
 
private:
	void _LeakDetector( );
};
 
// 静态对象
static LeakDetector exitCounter;

// 初始化 LeakDetector类中定义的静态变量
size_t LeakDetector::_callCount = 0;










3. 设计模式
创建型的设计模式
	简单工厂模式: 工厂角色（传入参数构建产品），产品角色
	工厂方法模式: 工厂角色（创建不同的产品），产品角色
	抽象工厂模式: 抽象工厂，具体工厂，抽象产品，具体产品

	单例模式


结构型的设计模式
	适配器模式:在adapter中组合target和adaptee的需求函数


	4. C++中的指针参数传递和引用参数传递
指针参数传递的本质是值传递, 传递的值是对象的地址, 在调用时形参会在函数栈中开辟空间用于存放传递过来的对象的地址,此时形参相当于是实参的副本, 对形参的任何操作都不会反映到实参上, 但是通过形参间接访问对象的修改是会反应到函数之外的.
引用参数传递的本质是传地址, 传递的是实参变量的地址, 首先形参会在函数栈中开辟空间用来存放实参变量的地址, 然后对该形参的任何操作都会被处理未间接寻址,即通过形参中的地址访问主调函数中的实参变量, 因为通过形参的任何操作都将被应用于主调函数中.
从逻辑上引用相当于对变量起了一个别名, 通过该别名可以对变量进行直接访问, 由编译器负责将直接访问转换为间接访问; 而指针访问变量都是间接访问.


5. 
形参与实参的区别？
形参属于函数内部的局部变量, 在调用函数时才会分配内存, 在函数调用之后会被释放掉, 因此在函数内部才有效
实参可以使常量, 表达式, 函数等, 无论是何种类型,在函数调用时都必须有一个确定的值,以便把函数的值传递给形参
实参和形参的个数一定要严格匹配(当然可以忽略有默认值形参), 通常情况下函数类型也是应该严格匹配的, 但是允许隐式类型变换,如果类中定义了零参数构造函数,甚至可以使用空初始化列表{}的方式调用零参数构造函数
实参到形参的传递是单向的
形参类型为非指针非引用, 则传递方式为值传递则, 形参为实参的副本, 对形参的任何修改都不会反应在主调函数中



6. 
static的用法
主要可以分为五个类型: 全局静态变量, 局部静态变量, 静态函数, 静态成员变量, 静态成员函数
全局静态变量
在全局变量前加上关键字static，全局变量就定义成一个全局静态变量.
内存中的位置：静态存储区，在整个程序运行期间一直存在。
初始化：未经初始化的全局静态变量会被自动初始化为0(对于自动对象,如果没有显示初始化,会调用零参数构造函数,如不存在则编译失败);
作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。
局部静态变量
在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。
内存中的位置：静态存储区
初始化：未经初始化的全局静态变量会被自动初始化为0(对于自动对象,如果没有显示初始化,会调用零参数构造函数,如不存在则编译失败)；
作用域：作用域仍为局部作用域，
当定义它的函数或者语句块结束的时候，作用域结束。
但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；

静态局部变量和全局变量一样，数据都存放在全局区域，所以在主程序之前，编译器已经为其分配好了内存

静态函数
在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。
函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；
warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；
类的静态成员
在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。
因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用
类的静态函数
静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。
在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员(这点非常重要)。*如果静态成员函数中要引用非静态成员时，可通过对象来引用。
从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);*
不能被virtual修饰,静态成员函数没有this 指针，虚函数的实现是为每一个对象分配一个vptr 指针，而vptr 是通过this 指针调用的，所以不能为virtual；虚函数的调用关系，this->vptr->ctable->virtual function


7.const 成员函数的理解和应用？
① const Stock & Stock::topval (②const Stock & s) ③const
① 处const：确保返回的Stock 对象在以后的使用中不能被修改
② 处const：确保此方法不修改传递的参数s
③ 处const：保证此方法不修改调用它的对象，const 对象只能调用const 成员函数,不能调用非const 函数


8. extern 用法？
extern 修饰变量的声明
如果文件a.c 需要引用b.c 中变量int v，就可以在a.c 中声明extern int v，然后就可以引用变量v。
extern 修饰函数的声明
如果文件a.c 需要引用b.c 中的函数，比如在b.c 中原型是int fun(int mu)，那么就可以在a.c 中声明extern int fun(int mu)，然后就能使用fun 来做任何事情。
就像变量的声明一样，extern int fun(int mu)可以放在a.c 中任何地方，而不一定非要放在a.c 的文件作用域的范围中。
默认情况情况下函数都是extern的, 除非使用static对函数进行了隐匿
extern 修饰符可用于指示C 或者C++函数的调用规范。
比如在C++中调用C 库函数，就需要在C++程序中用extern “C”声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用C 函数规范来链接。主要原因是C++和C 程序编译完成后在目标代码中命名规则不同。


9. 深拷贝与浅拷贝？
浅复制:
只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做“(浅复制)浅拷贝”，
换句话说，浅复制仅仅是指向被复制的内存地址，如果原地址中对象被改变了，那么浅复制出来的对象也会相应改变。
深复制: 在计算机中开辟了一块新的内存地址用于存放复制的对象。
浅复制的问题:
在某些状况下，类内成员变量需要动态开辟堆内存，如果实行位拷贝，也就是把对象里的值完全复制给另一个对象，如A=B。
这时，如果B 中有一个成员变量指针已经申请了内存，那A 中的那个成员变量也指向同一块内存。
这就出现了问题：当B把内存释放了(如：析构)，这时A 内的指针就是野指针了，出现运行错误。


10. C++模板是什么，底层怎么实现的？
编译器并不是把函数模板处理成能够处理任意类的函数；编译器从函数模板通过具体类型产生不同的函数；
编译器会对函数模板进行两次编译：
	在声明的地方对模板代码本身进行编译，
	在调用的地方对参数替换后的代码进行编译。
这是因为函数模板要被实例化后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误。

模板可以重载返回值, 函数重载不行

模板函数会经历两遍编译:
	(模板编译)在定义模板函数时对模板本身进行编译
	(模板实例化)在调用时对参数进行替换, 对替换参数后的代码进行编译


11. 虚函数可以声明为inline吗?
虚函数要求在运行时进行类型确定，而内联函数要求在编译期完成相关的函数替换, 所以不能
虚函数用于实现运行时的多态，或者称为晚绑定或动态绑定。
内联函数用于提高效率, 对于程序中需要频繁使用和调用的小函数非常有用。它是在编译期间，对调用内联函数的地方的代码替换成函数代码。



12. 成员列表初始化？
必须使用成员初始化的四种情况
当初始化一个引用成员时；
当初始化一个常量成员时；
基类， 无零参数构造函数时
成员类， 无零参数构造函数时



13. 构造函数为什么不能为虚函数?
	在对象中插入一个指向虚函数表的指针是由构造函数完成的, 也就是说在调用构造函数时并没有指向虚函数表的指针, 也就不能完成虚函数的调用


14. 构造函数析构函数可以调用虚函数吗？
在构造函数和析构函数中最好不要调用虚函数；
在构造函数和析构函数中调用的成员函数都是属于编译时确定的,并不具有虚函数的动态绑定特性, 有如下原因:
在构造时, 父类对象总是先于子类对象构造的, 如果父类的析构函数使用虚函数机制调用子类的函数, 结果将是不可预料的
在析构时, 子类的析构函数总是先于父类执行, 如果父类的析构函数使用虚函数机制调用子类的函数, 结果将是不可预料的



15. 构造函数, 析构函数可否抛出异常
构造函数异常
后果:
(原因):C++拒绝为没有完成构造函数的对象调用析构函数，原因是避免开销
构造函数中发生异常，控制权转出构造函数。如果构造函数中申请了堆内存, 则堆内存将无法释放, 从而造成内存泄漏
例如: 在对象b 的构造函数中发生异常，对象b 的析构函数不会被调用。因此会造成内存泄漏。
解决方案:
使用智慧指针来管理堆内存. 其不需要在析构函数中手动释放资源. 在发生异常时, 智慧指针会自动释放资源从而避免了内存泄漏.
一般建议不要在构造函数里做过多的资源分配。
析构函数异常
后果:
在异常传递的堆栈辗转开解的过程中, 如果发生析构异常, C++会调用terminate终止程序
如果析构函数发生发生异常，则异常后面的代码将不执行，无法确保完成我们想做的清理工作。
解决方法：
如果异常不可避免，则应在析构函数内捕获，而不应当抛出。
在析构函数中使用try-catch块屏蔽所有异常。
附加说明:
(后果1): 如果某一个异常发生,某对象的析构函数被调用,而此时析构发生了异常并流出了函数之外,则函数会被立即terminate掉(函数外有catch也不能拯救)



16.
类如何实现只能静态分配和只能动态分配
建立类的对象有两种方式：
静态建立(栈空间)
静态建立一个类对象，就是由编译器为对象在栈空间中分配内存, 然后调用构造函数初始化这片内存空间.
使用这种方法，直接调用类的构造函数。
动态建立(堆空间)，A *p = new A();
动态建立类对象, 使用new操作符将在堆空间分配内存, 然后调用构造函数初始化这片内存空间.
这种方法，间接调用类的构造函数。
只能在堆上建立
分析: 类对象只能建立在堆上，就是不能静态建立类对象，即不能直接调用类的构造函数。
实现方式: 将析构函数设为私有或则受保护
方法分析:
静态建立:
当对象建立在栈上面时，是由编译器分配内存空间的，调用构造函数来构造栈对象。
当对象使用完后，编译器会调用析构函数来释放栈对象所占的空间。
编译器管理了对象的整个生命周期。
编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，
其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。
如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。
因此，将析构函数设为私有，类对象就无法建立在栈上了。
由此引发的问题:
因为析构函数设置为了私有
需要设置一个public函数来调用析构函数
代码如下：
  class  A  
  {  
  protected :  
  A(){}  
  ~A(){}  
  public :  
  static  A* create()  
  {  
      return   new  A();  
  }  
  void  destory()  
  {  
      delete   this ;  
  }  
  };  
只能在栈上建立
只有使用new运算符，对象才会建立在堆上，因此，只要禁用new运算符就可以实现类对象只能建立在栈上。将operator new()设为私有即可。
注意: 重载了new就需要重载delete
代码如下：
  class  A  
  {  
  private :  
      void * operator  new ( size_t  t){}      // 注意函数的第一个参数和返回值都是固定的 
      void  operator  delete ( void * ptr){}  // 重载了new就需要重载delete 
  public :  
      A(){}  
      ~A(){}  
  }; 





17. 如果想将某个类用作基类，为什么该类必须定义而非声明？
因为在继承体系下, 子类会继承父类的成员, 并且编译器会在子类的构造函数和析构函数中插入父类的构造和析构部分, 因而父类必须有定义


18. 什么是类的继承？
类与类之间的关系
(has-A)包含关系，即一个类的成员属性是另一个已经定义好的类
(use-A)使用关系, 一个类使用另一个类，通过类之间的成员函数相互联系，定义友元或者通过传递参数的方式实现；
(is-A)继承关系, 继承关系，关系具有传递性；
继承的相关概念
所谓的继承就是一个类继承了另一个类的属性和方法，这个新的类包含了上一个类的属性和方法，
被称为子类或者派生类，被继承的类称为父类或者基类；
继承的特点
子类拥有父类的所有属性和方法，子类对象可以当做父类对象使用；
子类可以拥有父类没有的属性和方法；
继承中的访问控制
public、protected、private
继承中的构造和析构函数
子类中构造函数的调用顺序为: 基类构造函数, 成员对象构造函数, 派生类构造函数
子类中析构函数的调用顺序为: 派生类析构函数, 成员对象析构函数, 基类析构函数
继承中的兼容性原则
类型兼容规则是指在需要基类对象的任何地方，都可以使用公有派生类的对象来替代。
参考: 继承中的类型兼容性原则 - Say舞步 - 博客园



19. 抽象基类为什么不能创建对象？
抽象类的定义：带有纯虚函数的类为抽象类。
抽象类的作用：
抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。
所以抽象类实际上刻画了一组子类的操作接口的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。
使用抽象类时注意：
抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。
如果派生类中没有给出所有纯虚函数的实现，而只是继承基类的纯虚函数，则这个派生类仍然是一个抽象类。
如果派生类中给出了所有纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。
抽象类是不能定义对象的




20. 类什么时候会析构？
对于静态对象: 当离开作用区域之后, 对象生命周期结束, 编译器会自动调用析构函数
对于动态对象: 当对对象指针调用delete时, 会调用析构函数终止对象生命周期并释放内存. 其中对象指针指针可以对象类型的指针, 也可以时基类指针(注意基类析构函数位虚函数)
第三种情况: 当对象中存在嵌入对象时, 该对象析构时, 嵌入对象也会被析构




21. 介绍一下C++里面的多态？
静态多态(重载, 模板): 是在编译的时候，就确定调用函数的类型。
动态多态(覆盖, 虚函数实现): 在运行的时候，才确定调用的是哪个函数，动态绑定。运行基类指针指向派生类的对象，并调用派生类的函数


22. 

继承机制中对象之间如何转换？指针和引用之间如何转换？
派生类的对象可以当做基类对象使用， 例如赋值或则初始化等
派生类对象的地址可以赋给指向基类的指针。 在替代之后，派生类对象就可以作为基类的对象使用，但只能使用从基类继承的成员。

向上类型转换(派生类转基类, 总是安全的)
	将派生类指针或引用转换为基类的指针或引用被称为向上类型转换，向上类型转换会自动进行，而且向上类型转换是安全的。
向下类型转换(基类转派生类, 不安全)
	将基类指针或引用转换为派生类指针或引用被称为向下类型转换，向下类型转换不会自动进行，因为一个基类对应几个派生类，所以向下类型转换时不知道对应哪个派生类，所以在向下类型转换时必须加动态类型识别技术。
	RTTI技术，用dynamic_cast进行向下类型转换, 只有存在虚函数的类才能使用RTTI，   运行期类型信息 (Run-time type information)


23.
移动构造函数
右值的概念: 将亡值, 不具名变量
右值引用
概念: 其本身是一个左值, 但是它绑定了一个右值, 此右值的生命周期将和此右值引用一致.
优点:
转移语意
精确语意传递(参数列表分别为左值引用和右值引用形成参数重载)
移动构造函数:
概念: 当我们使用一个即将消亡的对象A初始化对象B时, 使用移动语意可以避免额外的无意义的复制构造操作, 也避免了释放内存, 新分配内存的开销.
实现:
移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用。
也就是说，只用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数。
作为参数的右值将不会再调用析构函数。
move语句，就是将一个左值变成一个将亡值。
优点
避免了无畏的对下销毁和构造的开销
当该类对象申请了堆内存, 并在析构函数中进行释放时, 使用拷贝构造函数可能会存产生也野指针, 而使用移动构造可以避免野指针的产生.



24. 函数指针？
什么是函数指针?
函数指针本质是一个指针, 它指向的是函数的入口地址, 它的类型是由函数的参数列表和返回值共同确定.
函数指针的声明方法
int (*pf)(const int&, const int&); (1)
pf是一个返回类型为int, 参数为两个const int&的函数。注意*pf 两边的括号是必须的
否则上面的定义就变成了：
int *pf(const int&, const int&); // 这声明了一个函数pf, 其返回类型为int *, 带有两个const int&参数.
为什么有函数指针
可以通过函数指针进行函数调用
而且函数指针本质是一个指针, 可以把它指向返回值类型和形参列表相同的不同函数
另外还能将函数指针作为函数参数进行传递.
通过函数指针可以把函数的调用者与被调函数分开。
调用者只需要确定被调函数是一个具有特定参数列表和特定返回值的函数,
而不需要知道具体是哪个函数被调用.
两种方法赋值：
指针名 = 函数名
指针名 = &函数名




25. 野指针是什么？如何检测内存泄漏？
野指针：指向内存被释放的内存或者没有访问权限的内存的指针。
“野指针”的成因主要有3 种：
指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL 指针，它的缺省值是随机的。
指针被free 或者delete 之后，没有置为NULL；
指针操作超越了变量的作用范围。
如何避免野指针：
对指针进行初始化, 或指向有效地址空间
指针用完后释放内存，将指针赋NULL。
char * p = NULL;
char * p = (char * )malloc(sizeof(char));
char num[ 30] = {0}; char *p = num;
delete(p); p = NULL;


悬空指针：一个指针的指向对象已被删除，那么就成了悬空指针。野指针是那些未初始化的指针


26.
手写实现智能指针类
参考: 说一下shared_ptr的实现
计数器: 取计数器,
指针相关: 取原始指针
运算符重载: ++, --, ->, +, -, *, =
构造函数: 更新计数器
复制构造函数: 更新计数器
移动构造函数: 计数器不变
析构函数: 更新计数器, 按条件释放内存

智能指针是一个数据类型，一般用模板实现，模拟指针行为的同时还提供自动垃圾回收机制。
它会自动记录SmartPointer<T*>对象的引用计数，一旦T 类型对象的引用计数为0，就释放该对象。
除了指针对象外，我们还需要一个引用计数的指针设定对象的值，并将引用计数计为1，需要一个构造函数。
新增对象还需要一个构造函数，析构函数负责引用计数减少和释放内存。
通过覆写赋值运算符，才能将一个旧的智能指针赋值给另一个指针，同时旧的引用计数减1，新的引用计数加1
一个构造函数、拷贝构造函数、复制构造函数、析构函数、移走函数


27.
内存对齐？位域？
字节对齐的原因:
更快: 如果数据未对齐自然边界, 则处理器需要两次寻址才能得到完整的数据
通用: 部分硬件平面不支持访问未对齐的数据, 会抛出硬件异常
具体操作
自定义对齐系数
可以通过预编译命令#pragma pack(n)，n=1,2,4,8,16来改变这一系数，其中的n就是指定的“对齐系数”
数据成员对齐规则:
结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。
结构体作为成员：
如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。
结构(或联合)的整体对齐规则：
在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。
位域
有些信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。
Ｃ语言又提供了一种数据结构，称为“位域”或“位段”。
所谓“位域”是把一个字节中的二进位划分为几 个不同的区域，并说明每个区域的位数。
位段成员必须声明为int、unsigned int或signed int类型(short char long)。 ```c struct 位域结构名{ 位域列表 // 其中位域列表的形式为： 类型说明符 位域名：位域长度 };
struct bs {
int a:8; int b:2; int c:6; };



28. C++类型转换有四种
const_cast:
用来移除const或volatile 属性。但需要特别注意的是const_cast不是用于去除变量的常量性，而是去除指向常数对象的指针或引用的常量性，其去除常量性的对象必须为指针或引用。
如果对一个指向常量的指针,通过const_cast移除const属性, 然后进行修改, 编译通过,但是运行时会报段错误
static_cast: 静态类型转换(不能移除const/volatile属性)是最常看到的类型转换, 几个功能.
内置类型之间的转换, 精度耗损需要有程序员把握
继承体系中的上下行转换(上行:子类转父类,安全转换; 下行:父类转子类, 不安全转换)
指针类型转换: 空指针转换成目标类型的空指针, 把任何类型转换成void 类型。
dynamic_cast: 主要用在继承体系中的安全向下转型
它能安全地将指向基类的指针/引用转型为指向子类的指针/引用, 转型失败会返回null(转型对象为指针时)或抛出异常bad_cast(转型对象为引用时)。
dynamic_cast 会利用运行时的信息(RTTI)来进行动态类型检查，因此dynamic_cast 存在一定的效率损失。
而且dynamic_cast进行动态类型检查时, 利用了虚表中的信息, 所以只能用于函数虚函数的类对象中.
reinterpret_cast 强制类型转换,非常不安全
它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针(先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值)。




29. 全局变量和static 变量的区别
static变量分为两个类型: 全局静态变量(在全局变量的类型前加上static)和局部静态变量(在局部变量的类型前加上static).
从储存形式看: 他们没有区别, 都储存于静态数据区
从作用域看:
全局变量默认具有extern属性, 它的作用域为整个项目, 可能和其他cpp文件中的全局变量发生命名冲突.
全局静态变量,作用域受限, 它的作用域仅限于定义它的文件内有效, 不会和其他cpp文件中的全局变量发生命名冲突.
局部静态变量, 作用域依旧不管, 当时当离开作用域时不会变量不会被释放, 其值保持不变只是被屏蔽了, 直到再次进入作用域, 其也只会被初始化一次.
static 函数与普通函数有什么区别？
static 函数与普通函数有什么区别？
static 函数与普通的函数作用域不同。
普通函数默认为extern属性, 作用域为整个项目, 可能会和其他cpp文件中的函数发生命名冲突.
static修饰的函数, 作用域受限仅为定义的文件, 不会和其他cpp文件中的函数发生命名冲突.


30. 静态成员与普通成员的区别
储存位置不同: 普通成员变量存储在栈或堆中，而静态成员变量存储在静态全局区；
声明周期不同:
静态成员变量从类被加载开始到类被卸载，一直存在；
普通成员变量只有在类创建对象后才开始存在，对象结束，它的生命期结束；
初始化位置: 普通成员变量在类中初始化；静态成员变量在类外初始化；
拥有则不同: 静态成员变量可以理解为是属于类的变量,可以通过类名进行访问, 为本类的所有对象所共享；普通成员变量是每个对象单独享用的, 只能通过对象进行访问


31. 多继承的优缺点，作为一个开发者怎么看待多继承
C++允许为一个派生类指定多个基类，这样的继承结构被称做多重继承。
优点: 对象可以调用多个基类中的接口；
缺点:
如果基类重存在多个相同的基类或则方法, 则会出现二义性(解决方案是调用时加上全局限定符)
容易存在菱形继承, 从而导致存在多个基类的副本(解决方案是使用虚拟继承)
个人觉得挺方便的, 虽然有缺点,但是也都用对应的解决方案


30.
大端模式：是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址端。 小端模式，是指数据的高字节保存在内存的高地址中，低位字节保存在在内存的低地址端


31. 为什么拷贝构造函数必须传引用不能传值？
拷贝构造函数的作用就是用来复制对象的，在使用这个对象的实例来初始化这个对象的一个新的实例。
两种不同的参数传递方式：

值传递:
对于内置数据类型的传递时，直接赋值拷贝给形参(注意形参是函数内局部变量)；对于类类型的传递时，需要首先调用该类的拷贝构造函数来初始化形参(局部对象)；
如void foo(class_type obj_local){}, 如果调用foo(obj); 首先class_type obj_local(obj) ,这样就定义了局部变量obj_local 供函数内部使用
引用传递:
无论对内置类型还是类类型，传递引用或指针最终都是传递的地址值！而地址总是指针类型(属于简单类型), 显然参数传递时，按简单类型的赋值拷贝，而不会有拷贝构造函数的调用(对于类类型).
拷贝构造函数使用值传递会产生无限递归调用，内存溢出。
拷贝构造函数用来初始化一个非引用类类型对象，如果用传值的方式进行传参数，那么构造实参需要调用拷贝构造函数，而拷贝构造函数需要传递实参，所以会一直递归



32. 你什么情况用指针当参数，什么时候用引用，为什么？

使用引用参数的主要原因有两个：
程序员能修改调用函数中的数据对象
通过传递引用而不是整个数据–对象，可以提高程序的运行速度
一般的原则：
对于使用数据对象不做修改的函数：
如果数据对象很小(内置数据类型或者小型结构)，则按照值传递；
如果数据对象是数组，则使用指针 (唯一的选择)，并且指针声明为 const 的指针；
如果数据对象是较大的结构，则使用 const 指针或者引用，已提高程序的效率。这样可以节省结构所需的时间和空间；
如果数据对象是类对象，则使用 const 引用(传递类对象参数的标准方式是按照引用传递)；
对于修改函数中数据的函数：
如果数据是内置数据类型，则使用指针
如果数据对象是数组，则只能使用指针
如果数据对象是结构，则使用引用或者指针
如果数据是类对象，则使用引用


33. 静态函数能定义为虚函数吗？常函数?
不能 !
static成员不属于任何类对象或类实例，没有this指针(静态与非静态成员函数的一个主要区别)。
虚函数调用链为: vptr -> vtable -> virtual function
但是访问vptr需要使用this指针但是static成员函数没有this指针, 从而无法实现虚函数的调用
虚函数依靠vptr 和vtable 来处理。vptr 是一个指针，在类的构造函数中创建生成，并且只能用this 指针来访问它，因为它是类的一个成员，
并且vptr 指向保存虚函数地址的vtable.对于静态成员函数，它没有this指针，所以无法访问vptr. 这就是为何static 函数不能为virtual.
虚函数的调用关系：this -> vtable -> virtual function


34.